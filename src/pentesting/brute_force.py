# src/pentesting/brute_force.py
from __future__ import annotations

import time
import requests
from pathlib import Path
from typing import List, Dict, Optional


# restricted to loopback to avoid real-world abuse
DATA_DIR = Path(__file__).resolve().parents[2] / "data"
DEFAULT_PW_FILE = DATA_DIR / "default_passwords.txt"
ALLOWED_HOSTS = {"127.0.0.1", "localhost"}


def load_default_passwords(path: Path | str = DEFAULT_PW_FILE) -> List[str]:
    # load a list of common IoT passwords
    p = Path(path)
    if not p.exists():
        return ["admin", "password", "123456"]
    return [
        line.strip()
        for line in p.read_text(encoding="utf-8").splitlines()
        if line.strip()
    ]


def _host_from_url(url: str) -> str:
    # host grab without full URL parsing
    return url.split("//")[-1].split("/")[0].split(":")[0]


def _is_success_response(
    r: requests.Response,
    body: str
) -> tuple[bool, float]:
    # guess auth success from status codes and page hints
    sc = getattr(r, "status_code", None)

    if sc in (302, 303):
        return True, 0.8

    if sc == 200:
        text = (body or "").lower()
        if any(k in text for k in ("welcome", "dashboard", "login successful", "logout")):
            return True, 0.9
        return False, 0.15

    return False, 0.0


def brute_force_http_login(
    target_url: str,
    username: str = "admin",
    passwords: Optional[List[str]] = None,
    stop_on_success: bool = True,
    rate_limit_delay: float = 0.5,
    max_attempts: Optional[int] = None,
) -> Dict:
    # simulate weak login resistance on local targets
    host = _host_from_url(target_url)
    if host not in ALLOWED_HOSTS:
        return {
            "target": target_url,
            "test": "brute_force_login",
            "error": "target_not_allowed",
            "detail": f"Target host {host} not permitted.",
        }

    if passwords is None:
        passwords = load_default_passwords()

    if max_attempts is not None:
        passwords = passwords[:max_attempts]

    session = requests.Session()
    session.headers.update({"User-Agent": "Auth-Test/1.0"})

    attempts: List[Dict] = []
    successes: List[Dict] = []
    stopped_early = False
    start_ms = time.time() * 1000.0

    for idx, pw in enumerate(passwords):
        t0 = time.time() * 1000.0
        try:
            r = session.post(
                target_url,
                data={"username": username, "password": pw},
                timeout=5,
                allow_redirects=False,
            )

            success, conf = _is_success_response(r, r.text)
            elapsed = round(time.time() * 1000.0 - t0, 1)

            attempt = {
                "attempt": idx + 1,
                "password": pw,
                "status": r.status_code,
                "success": success,
                "confidence": round(conf, 2),
                "time_ms": elapsed,
                "note": "",
            }

            attempts.append(attempt)

            if success:
                successes.append(attempt)
                if stop_on_success:
                    stopped_early = True
                    break

        except Exception as e:
            elapsed = round(time.time() * 1000.0 - t0, 1)
            attempts.append({
                "attempt": idx + 1,
                "password": pw,
                "error": str(e),
                "time_ms": elapsed,
            })

        # pause between tries to mimic throttling
        time.sleep(rate_limit_delay)

    return {
        "target": target_url,
        "test": "brute_force_login",
        "attempts_count": len(attempts),
        "success_count": len(successes),
        "stopped_early": stopped_early,
        "duration_ms": round(time.time() * 1000.0 - start_ms, 1),
        "attempts": attempts,
        "successes": successes,
    }
